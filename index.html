<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			var arr = [4,3,8,9,10,356,14,56,76,43,234,90];
			function sortDesc(arr){
				var tempArr = arr;
				var tempStr = '';
				var len = arr.length;
				for(var i=0;i<len;i++){//N-1回合
					for(var j=0;j<len;j++){//N-1次比较
						if(tempArr[i]<tempArr[j]){
							tempStr = tempArr[i];
							tempArr[i]=tempArr[j];
							tempArr[j]=tempStr;
						}
					}
				}
				return tempArr;
			}
//			alert(sortDesc(arr));
		</script>
		<script type="text/javascript">
			//二分搜索法
//			var arr = [4,3,8,9,10,356,49,56,76,43,234,90];
			var arr = [419,33];
			var key = 49;
			function findKeyByM(key,arr){
				var startIndex = 0;
				var endIndex = arr.length-1;
				while(1){
					if(endIndex<=startIndex)break;
					var mIndex = parseInt((startIndex+endIndex)/2);
					var aCtn = arr[mIndex];
					if(aCtn==key){
						alert(aCtn);
						break;
					}else if(key>aCtn){
						startIndex = mIndex+1;
					}else if(key<aCtn){
						endIndex = mIndex -1;
					}else{
						alert("没有该内容");
						break;
					}
					
				}
			}
//			findKeyByM(49,arr);
		</script>
		<script type="text/javascript">
			function binarySearch(data, dest, start, end){
			    var end = end || data.length - 1,
			        start = start || 0,
			        m = Math.floor((start + end) / 2);
			    
			    if(data[m] == dest){
			        return m;
			    }
			    
			    if(dest < data[m]){
			        return binarySearch(data, dest, 0, m-1);
			    }else{
			        return binarySearch(data, dest, m+1, end);
			    }
			   
			    return false;
			}
			var arr = [-34, 1, 3, 4, 5, 8, 34, 45, 65, 87];
			alert(binarySearch(arr,34));
			//3
		</script>
		<!--
			排序
			意义：资料有小到大或者由大到小排序
			方法：(1)内部排序法-----主要记忆---快===资料量小
				  （2)外部排序法----辅助记忆---慢===资料量大
				  
			    全局脚本对象
			    <script type="text/javascript">
			        __CFG = new Object;
			        __CFG.rootpath   = '/index';
			        __CFG.staticroot = '/Style/newStatic';
			        __CFG.statichost = '';
			        __CFG.revision   = 'v=201511091613';
			        __CFG.uid        = '0';
			        __CFG.username   = '';
			    </script>
			    全局脚本对象
			    
			 气泡排序法（冒泡排序）
			 原理：让两个相邻资料比较
			 若有N个数
			 ------要比较: N-1回合
			 ------比较次数：N*(N-1)/2
			 
			 6,3,9,2
			 -----回合：3回
			 -----比较次数：6次
			------比较有数列的规律，每次能确定一个最大的，或者最小的
			     
			二分搜寻法：
			（1）资料需事先排序，由大到小或者由小到大
			（2)方式：如由小到大，要搜索x值
			 ------讲x值域资料中的中间值做比较
			 如家：x=中间值---》直接打印出在阵列中的位置
			     x>中间值---》资料左半部分放弃
			     x<中间值---》资料右半部分放弃
			（3）N笔资料，比较次数最多不超过log2(N+1)次
			一般地，函数y=logax（a>0，且a≠1）叫做对数函数，也就是说以幂为自变量，指数为因变量，底数为常量的函数，叫对数函数。
		    *向下取整
			Math.floor(5/2)
		    
		    搜寻：
		    （1）意义：在一组资料中，根据条件找出所需的特质资料
		    （2）方法：循序搜寻法，二分搜寻法
		    
		    循序搜寻法：
		       --资料不需要事先排序，从第一笔资料开始，一笔一笔往下找，若找到，就印出；若没有找到，就印出”没找到“
		       --若有N个数
		       	 寻找次数最多N次
		       	                最少1次
		       	                平均为（N+1）/2
		    
		 堆叠、队列：
		 -----后进先出
		 -----统一由一端进入
		 
		 
		 送：从上到下
		 收：从下到上
			 雇佣层/应用程序
			        ---Browser(IE/chrome/-----http)  port:80
			 		----MSN:---IM(即时通讯)
			 		----main--outlook{SMTP发/POP收}
			 表现层
			 		----资料结构/文件加密和解密
			 交谈层/会谈层/会话层
			        ----传送之前准备工作：连线建立，管理，结束
			 传输层
			        ----适当切割要传送的资料，确定怎么送（TCP[挂号信]/UDP【平送】）
			 网路层
			        ----IP【对方的住址----常用的地址是IP】
			 资料连接层
			        ----MAC地址
			 实体层
			        ----传送的媒介【网路媒介--1、有线{铜线或者光纤}；2、无线的】
			        数位（010101）：
			                   转成成光的信号
			                   转成电压的信号
		-->
	</head>
	<body>
		<pre>
						排序
			意义：资料有小到大或者由大到小排序
			方法：(1)内部排序法-----主要记忆---快===资料量小
				  （2)外部排序法----辅助记忆---慢===资料量大
				  
			    全局脚本对象
			    <script type="text/javascript">
			        __CFG = new Object;
			        __CFG.rootpath   = '/index';
			        __CFG.staticroot = '/Style/newStatic';
			        __CFG.statichost = '';
			        __CFG.revision   = 'v=201511091613';
			        __CFG.uid        = '0';
			        __CFG.username   = '';
			    </script>
			    全局脚本对象
			    
			 气泡排序法（冒泡排序）
			 原理：让两个相邻资料比较
			 若有N个数
			 ------要比较: N-1回合
			 ------比较次数：N*(N-1)/2
			 
			 6,3,9,2
			 -----回合：3回
			 -----比较次数：6次
			------比较有数列的规律，每次能确定一个最大的，或者最小的
			     
			二分搜寻法：
			（1）资料需事先排序，由大到小或者由小到大
			（2)方式：如由小到大，要搜索x值
			 ------讲x值域资料中的中间值做比较
			 如家：x=中间值---》直接打印出在阵列中的位置
			     x>中间值---》资料左半部分放弃
			     x<中间值---》资料右半部分放弃
			（3）N笔资料，比较次数最多不超过log2(N+1)次
			一般地，函数y=logax（a>0，且a≠1）叫做对数函数，也就是说以幂为自变量，指数为因变量，底数为常量的函数，叫对数函数。
		    *向下取整
			Math.floor(5/2)
		    
		    搜寻：
		    （1）意义：在一组资料中，根据条件找出所需的特质资料
		    （2）方法：循序搜寻法，二分搜寻法
		    
		    循序搜寻法：
		       --资料不需要事先排序，从第一笔资料开始，一笔一笔往下找，若找到，就印出；若没有找到，就印出”没找到“
		       --若有N个数
		       	 寻找次数最多N次
		       	                最少1次
		       	                平均为（N+1）/2
		    
		 堆叠、队列：
		 -----后进先出
		 -----统一由一端进入
		 
		 
		 送：从上到下
		 收：从下到上
			 雇佣层/应用程序
			        ---Browser(IE/chrome/-----http)  port:80
			 		----MSN:---IM(即时通讯)
			 		----main--outlook{SMTP发/POP收}
			 表现层
			 		----资料结构/文件加密和解密
			 交谈层/会谈层/会话层
			        ----传送之前准备工作：连线建立，管理，结束
			 传输层
			        ----适当切割要传送的资料，确定怎么送（TCP[挂号信]/UDP【平送】）
			 网路层
			        ----IP【对方的住址----常用的地址是IP】
			 资料连接层
			        ----MAC地址
			 实体层
			        ----传送的媒介【网路媒介--1、有线{铜线或者光纤}；2、无线的】
			        数位（010101）：
			                   转成成光的信号
			                   转成电压的信号
		</pre>
	</body>
</html>
